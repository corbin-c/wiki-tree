qimport { ForceGraph3D } from "react-force-graph";
import React, { useState, useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import WikiAPI from "../wikiApi.js";

let api;

const Graph = (props) => {
  const {
    lang,
    searchString,
    actionInput,
    handleActions
  } = props;
  const dispatch = useDispatch();
  const nodes = useSelector(state => state.nodes);
  const edges = useSelector(state => state.edges);
  
  const createNode = async (options) => {
    const {
      ns,
      pageid,
      title
    } = options;
    if (typeof pageid === "undefined") { //this is a "missing" article
      return;
    }
    if (pageid === false) { //this is coming from our search form
      const url = api.buildRequest({
        action: "query",
        list: "search",
        srsearch: title,
        srnamespace: 0,
        srlimit: 1
      })[0].url;
      let results = await fetch(url);
      results = await results.json();
      results = results.query.search[0];
      createNode(results);
      articlesLookup({
        pageids: [results.pageid]
      },true);
      return;
    }
    dispatch({ type: "nodes/create", payload: {
      id: pageid,
      entity: (ns === 0) ? "article" : "category",
      name: title
    }});
  }
  const createEdge = (options) => {
    const {
      entity,
      input,
      output,
      duplex,
      distance
    } = options;
    dispatch({ type: "edges/create", payload: {
      entity,
      source: input,
      target: output,
      duplex,
      distance
    }});
  }
  const removeNode = (id) => {
    console.log(id, nodes[id]);
    nodes[id].edges.forEach(e => {
      removeEdge(e);
    });
    dispatch({ type: "nodes/remove", payload: { id }});
  }
  const removeEdge = async (id) => {
    dispatch({ type: "edges/unlink", payload: { id }});
    dispatch({ type: "edges/remove", payload: { id }});
  }
  const categoriesLookup = (options) => {
    const callback = (id, pages) => {
      pages.forEach(async e => {
        if (typeof nodes[e.pageid] === "undefined") {
          createNode({
            ns: e.ns,
            pageid: e.pageid,
            title: e.title
          });
        }
        createEdge({
          entity: "taxonomy",
          output: id,
          input: e.pageid,
          duplex: true,
          distance: 3
        });
      });
      const toLookup = pages.filter(e => e.ns === 0); //add smthg for filtering already loaded nodes
      //~ articlesLookup({
        //~ pageids: toLookup.map(e => e.pageid)
      //~ });
    }
    options.action = "query";
    options.list = "categorymembers";
    options.cmlimit = 500;
    options.cmtype = ["page", "subcat"];
    lookup(options, callback);
    dispatch({ type: "nodes/loaded", payload: { id: options.cmpageid } });
  }
  const articlesLookup = (options, init=false) => {
    const callback = (page, linkOptions) => {
      if (typeof page.pageid === "undefined") {
        return;
      }
      if (typeof nodes[page.pageid] === "undefined") {
        createNode({
          ns: page.ns,
          pageid: page.pageid,
          title: page.title
        });
      }
      createEdge(linkOptions);
    }
    const lhCallback = (id, links) => {
      console.log("lhCallback");
      Object.values(links).forEach(page => {
        Object.values(page.linkshere).forEach(e => {
          callback(e, {
            entity: "backlink",
            output: id,
            input: e.pageid,
            duplex: false,
            distance: 2
          });
        });
      });
    };
    const plCallback = (id, links) => {
      console.log("plCallback");
      Object.values(links).forEach(e => {
        console.log(id, e.pageid);
        callback(e, {
          entity: "outlink",
          input: id,
          output: e.pageid,
          duplex: false,
          distance: 2
        });
      });
    };
    const clCallback = (id, categories) => {
      console.log("clCallback");
      Object.values(categories).forEach(e => {
        callback(e, {
          entity: "taxonomy",
          input: id,
          output: e.pageid,
          duplex: true,
          distance: 3
        });
      });
    }
    options.action = "query";
    const lhOptions = { ...options };
    const plOptions = { ...options };
    const clOptions = { ...options };
    lhOptions.prop = ["linkshere"];
    lhOptions.lhlimit = 500;
    lhOptions.lhnamespace = 0;

    plOptions.gpllimit = 500;
    plOptions.gplnamespace = 0;
    plOptions.generator = "links";
    plOptions.prop = "info";

    clOptions.gcllimit = 500;
    clOptions.generator = "categories";
    clOptions.prop = "info";
    clOptions.gclshow = "!hidden";
  
    [
      [clOptions, clCallback],
      [plOptions, plCallback],
      [lhOptions, lhCallback],
    ].forEach(e => {
      lookup(e[0],e[1]);
    });
    dispatch({ type: "nodes/loaded", payload: { id: options.pageids } });
  }
  const lookup = (options, callback) => {
    const getResults = async (generator, callback, id) => {
      let results = (await generator.next()).value;
      if (typeof results === "undefined") {
        return;
      }
      //~ setTimeout(() => { getResults(generator, callback, id); }, 0);
      setTimeout(async () => {
        delete results.redirects;
        results = results[Object.keys(results)[0]];
        callback(id, results)
      }, 0);
    }
    api.buildRequest(options).forEach(r => {
      const resultsGenerator = api.fetchAndContinue(r.url);
      getResults(resultsGenerator, callback, r.pageid || r.cmpageid);
    });
  }

  useEffect(() => {
    const wikiAPI = new WikiAPI(lang); 
    api = wikiAPI;
    createNode({
      ns: 0,
      title: searchString,
      pageid: false
    });
  },[]);
  
  useEffect(() => {
    if (!actionInput.action) {
      return;
    }
    const action = actionInput.action;
    const options = actionInput.options;
    switch (action) {
      case "addSearch":
        createNode({
          ns: 0,
          title: options.searchString,
          pageid: false
        });
        return;
      case "articlesLookup":
        articlesLookup(options);
        return;
      case "removeNode":
        removeNode(options.id);
        return;
      case "categoriesLookup":
        categoriesLookup(options);
        return;
      default:
        return;
    }
  }, [actionInput]);
  useEffect(() => {
    console.log(nodes);
  },[nodes]);
  return (
    <ForceGraph3D
      linkOpacity={0.25}
      linkColor={ e => {
          switch (e.entity) {
            case "backlink":
              return "#1b5299";
            case "outlink":
              return "#1b5299";
            case "taxonomy":
              return "#fbfbf2";
            default:
              return "#fbfbf2";
          }
        }
      }
      onNodeClick={
        (e) => {
          handleActions({
            component: e.entity,
            title: e.name,
            id: e.id
          });
        }
      }
      nodeColor={ e => e.entity === "category" ? "#ea526f":"#1b5299" }
      nodeOpacity={1}
      backgroundColor="rgba(0,0,0,0)"
      graphData={{
        nodes: nodes,
        links: edges
      }}
    />
  )
  //~ return (<></>)
}

export default Graph;
